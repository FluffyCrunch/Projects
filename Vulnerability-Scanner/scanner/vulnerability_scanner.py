import requests
import socket
import ssl
import dns.resolver
import re
from urllib.parse import urlparse
import nmap
import concurrent.futures
from datetime import datetime
import json
import logging
import argparse

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class VulnerabilityScanner:
    def __init__(self, target_url):
        self.target_url = target_url
        self.parsed_url = urlparse(target_url)
        self.hostname = self.parsed_url.netloc
        self.scheme = self.parsed_url.scheme
        self.vulnerabilities = []
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        }

    def scan(self):
        """Run all vulnerability checks"""
        try:
            # Run checks concurrently
            with concurrent.futures.ThreadPoolExecutor(max_workers=8) as executor:
                futures = [
                    executor.submit(self.check_ssl_tls),
                    executor.submit(self.check_headers),
                    executor.submit(self.check_open_ports),
                    executor.submit(self.check_xss_vulnerability),
                    executor.submit(self.check_sql_injection),
                    executor.submit(self.check_csrf),
                    executor.submit(self.check_dns_security),
                    executor.submit(self.check_server_info_disclosure),
                    executor.submit(self.check_hsts),
                    executor.submit(self.check_spf_records),
                    executor.submit(self.check_server_version_outdated),
                    executor.submit(self.check_software_version_disclosure)
                ]
                
                for future in concurrent.futures.as_completed(futures):
                    try:
                        result = future.result()
                        if result:
                            self.vulnerabilities.extend(result)
                    except Exception as e:
                        logger.error(f"Error in scan: {str(e)}")

            return self.vulnerabilities

        except Exception as e:
            logger.error(f"Scan failed: {str(e)}")
            return []

    def check_ssl_tls(self):
        """Check SSL/TLS configuration"""
        vulnerabilities = []
        try:
            if self.scheme == 'https':
                context = ssl.create_default_context()
                with socket.create_connection((self.hostname, 443)) as sock:
                    with context.wrap_socket(sock, server_hostname=self.hostname) as ssock:
                        cert = ssock.getpeercert()
                        
                        # Check certificate expiration
                        if not cert:
                            vulnerabilities.append({
                                'type': 'SSL/TLS',
                                'severity': 'High',
                                'details': 'Invalid SSL certificate',
                                'timestamp': datetime.now().isoformat()
                            })
                        
                        # Check TLS version
                        if ssock.version() in ['SSLv2', 'SSLv3', 'TLSv1.0', 'TLSv1.1']:
                            vulnerabilities.append({
                                'type': 'SSL/TLS',
                                'severity': 'High',
                                'details': f'Outdated TLS version: {ssock.version()}',
                                'timestamp': datetime.now().isoformat()
                            })
        except Exception as e:
            vulnerabilities.append({
                'type': 'SSL/TLS',
                'severity': 'High',
                'details': f'SSL/TLS Error: {str(e)}',
                'timestamp': datetime.now().isoformat()
            })
        return vulnerabilities

    def check_headers(self):
        """Check security headers"""
        vulnerabilities = []
        try:
            response = requests.get(self.target_url, headers=self.headers, verify=False)
            headers = response.headers

            # Check for missing security headers
            security_headers = {
                'X-Frame-Options': 'Missing X-Frame-Options header (clickjacking protection)',
                'X-Content-Type-Options': 'Missing X-Content-Type-Options header (MIME-sniffing protection)',
                'Strict-Transport-Security': 'Missing HSTS header (HTTPS enforcement)',
                'Content-Security-Policy': 'Missing Content-Security-Policy header (XSS protection)',
                'X-XSS-Protection': 'Missing X-XSS-Protection header'
            }

            for header, message in security_headers.items():
                if header not in headers:
                    vulnerabilities.append({
                        'type': 'Security Headers',
                        'severity': 'Medium',
                        'details': message,
                        'timestamp': datetime.now().isoformat()
                    })
        except Exception as e:
            logger.error(f"Error checking headers: {str(e)}")
        return vulnerabilities

    def check_open_ports(self):
        """Scan for open ports using Nmap"""
        vulnerabilities = []
        try:
            nm = nmap.PortScanner()
            nm.scan(self.hostname, arguments='-sV -T4')
            
            for host in nm.all_hosts():
                for proto in nm[host].all_protocols():
                    ports = nm[host][proto].keys()
                    for port in ports:
                        service = nm[host][proto][port]
                        if port in [21, 23, 3389]:  # Common vulnerable ports
                            vulnerabilities.append({
                                'type': 'Open Port',
                                'severity': 'High',
                                'details': f'Potentially vulnerable port {port} ({service["name"]}) is open',
                                'timestamp': datetime.now().isoformat()
                            })
        except Exception as e:
            logger.error(f"Error scanning portSs: {str(e)}")
        return vulnerabilities

    def check_xss_vulnerability(self):
        """Check for XSS vulnerabilities"""
        vulnerabilities = []
        try:
            # Test for reflected XSS
            xss_payloads = [
                '<script>alert(1)</script>',
                '"><script>alert(1)</script>',
                '"><img src=x onerror=alert(1)>',
                '\'\';!--"<XSS>=&{()}',
                '<svg/onload=alert(1)>',
                'javascript:alert(1)',
                '<body onload=alert(1)>',
                '<iframe src="javascript:alert(1)"></iframe>',
                '<input autofocus onfocus=alert(1)>'
            ]
            
            # Test forms and parameters
            response = requests.get(self.target_url, headers=self.headers, verify=False)
            
            # Test URL parameters for reflection
            for payload in xss_payloads:
                test_url = f"{self.target_url}?q={payload}"
                test_response = requests.get(test_url, headers=self.headers, verify=False)
                if payload in test_response.text:
                    vulnerabilities.append({
                        'type': 'XSS',
                        'severity': 'High',
                        'details': f'Reflected XSS vulnerability detected. Payload: {payload}',
                        'timestamp': datetime.now().isoformat()
                    })
                    break
            
            # Look for forms to test
            forms = re.findall(r'<form[^>]*>.*?</form>', response.text, re.DOTALL)
            for form in forms:
                # Extract form action
                action_match = re.search(r'action=[\'"]([^\'"]*)[\'"]', form)
                if action_match:
                    form_action = action_match.group(1)
                    if not form_action.startswith('http'):
                        if form_action.startswith('/'):
                            form_action = f"{self.scheme}://{self.hostname}{form_action}"
                        else:
                            form_action = f"{self.target_url}/{form_action}"
                            
                    # Extract input fields
                    inputs = re.findall(r'<input[^>]*>', form)
                    if inputs:
                        form_data = {}
                        for input_field in inputs:
                            name_match = re.search(r'name=[\'"]([^\'"]*)[\'"]', input_field)
                            if name_match:
                                input_name = name_match.group(1)
                                form_data[input_name] = xss_payloads[0]  # Test first payload
                                
                        if form_data:
                            try:
                                form_response = requests.post(form_action, data=form_data, headers=self.headers, verify=False, timeout=5)
                                if xss_payloads[0] in form_response.text:
                                    vulnerabilities.append({
                                        'type': 'XSS',
                                        'severity': 'High',
                                        'details': f'XSS vulnerability detected in form submission to {form_action}',
                                        'timestamp': datetime.now().isoformat()
                                    })
                            except Exception as form_error:
                                logger.error(f"Error testing form XSS: {str(form_error)}")
                                
        except Exception as e:
            logger.error(f"Error checking XSS: {str(e)}")
        return vulnerabilities

    def check_sql_injection(self):
        """Check for SQL injection vulnerabilities"""
        vulnerabilities = []
        try:
            # Test for SQL injection
            sql_payloads = [
                "' OR '1'='1",
                "1' OR '1'='1",
                "1; SELECT * FROM users",
                "1' OR 1=1 --",
                "' UNION SELECT NULL,NULL,NULL-- ",
                "admin' --",
                "1' AND 1=2 UNION SELECT 1,2,3,4,5-- ",
                "1' WAITFOR DELAY '0:0:5'--",
                "1' AND (SELECT * FROM (SELECT(SLEEP(5)))a)-- ",
                "1') OR ('1'='1"
            ]
            
            # SQL error patterns
            sql_errors = [
                "SQL syntax",
                "mysql_fetch_array",
                "ORA-",
                "PostgreSQL",
                "SQLite3::",
                "Microsoft SQL Server",
                "mysqli_",
                "syntax error",
                "unclosed quotation mark",
                "mysql_query",
                "pg_query",
                "SQL syntax.*?MySQL",
                "Warning.*?mysql_",
                "valid MySQL result",
                "Oracle.*?Driver",
                "PostgreSQL.*?ERROR"
            ]
            
            # Find potential injection points (URL parameters)
            response = requests.get(self.target_url, headers=self.headers, verify=False)
            parsed_url = urlparse(self.target_url)
            
            # Test URL parameters
            params = {}
            if parsed_url.query:
                query_params = parsed_url.query.split('&')
                for param in query_params:
                    if '=' in param:
                        key, value = param.split('=', 1)
                        params[key] = value
            
            # If no parameters found, test common ones
            if not params:
                params = {'id': '1', 'page': '1', 'user': 'test', 'search': 'test'}
            
            # Test each parameter with each payload
            for param_name, param_value in params.items():
                for payload in sql_payloads:
                    test_params = params.copy()
                    test_params[param_name] = payload
                    
                    try:
                        test_response = requests.get(
                            f"{self.scheme}://{self.hostname}{parsed_url.path}", 
                            params=test_params, 
                            headers=self.headers, 
                            verify=False,
                            timeout=10
                        )
                        
                        # Check for SQL error messages in response
                        response_text = test_response.text.lower()
                        for error in sql_errors:
                            if error.lower() in response_text:
                                vulnerabilities.append({
                                    'type': 'SQL Injection',
                                    'severity': 'Critical',
                                    'details': f'SQL injection vulnerability detected in parameter "{param_name}" with payload: {payload}',
                                    'timestamp': datetime.now().isoformat()
                                })
                                # Break to avoid duplicate findings for same parameter
                                break
                                
                        # Time-based detection - check if response time is significantly different
                        if "WAITFOR DELAY" in payload or "SLEEP" in payload:
                            if test_response.elapsed.total_seconds() > 4.5:
                                vulnerabilities.append({
                                    'type': 'SQL Injection',
                                    'severity': 'Critical',
                                    'details': f'Time-based SQL injection detected in parameter "{param_name}"',
                                    'timestamp': datetime.now().isoformat()
                                })
                    except requests.exceptions.Timeout:
                        # If timeout occurs with time-based payload, likely vulnerable
                        if "WAITFOR DELAY" in payload or "SLEEP" in payload:
                            vulnerabilities.append({
                                'type': 'SQL Injection',
                                'severity': 'Critical',
                                'details': f'Time-based SQL injection detected in parameter "{param_name}" (request timed out)',
                                'timestamp': datetime.now().isoformat()
                            })
                    except Exception as e:
                        logger.error(f"Error testing SQL injection payload: {str(e)}")
                        
            # Test forms
            forms = re.findall(r'<form[^>]*>.*?</form>', response.text, re.DOTALL)
            for form in forms:
                action_match = re.search(r'action=[\'"]([^\'"]*)[\'"]', form)
                if action_match:
                    form_action = action_match.group(1)
                    if not form_action.startswith('http'):
                        if form_action.startswith('/'):
                            form_action = f"{self.scheme}://{self.hostname}{form_action}"
                        else:
                            form_action = f"{self.target_url}/{form_action}"
                            
                    # Extract input fields
                    inputs = re.findall(r'<input[^>]*>', form)
                    if inputs:
                        for sql_payload in sql_payloads[:3]:  # Use fewer payloads for forms
                            form_data = {}
                            for input_field in inputs:
                                name_match = re.search(r'name=[\'"]([^\'"]*)[\'"]', input_field)
                                if name_match:
                                    input_name = name_match.group(1)
                                    form_data[input_name] = sql_payload
                                    
                            if form_data:
                                try:
                                    form_response = requests.post(form_action, data=form_data, headers=self.headers, verify=False, timeout=5)
                                    response_text = form_response.text.lower()
                                    for error in sql_errors:
                                        if error.lower() in response_text:
                                            vulnerabilities.append({
                                                'type': 'SQL Injection',
                                                'severity': 'Critical',
                                                'details': f'SQL injection vulnerability detected in form submission to {form_action}',
                                                'timestamp': datetime.now().isoformat()
                                            })
                                            break
                                except Exception as form_error:
                                    logger.error(f"Error testing form SQL injection: {str(form_error)}")

        except Exception as e:
            logger.error(f"Error checking SQL injection: {str(e)}")
        return vulnerabilities

    def check_csrf(self):
        """Check for CSRF vulnerabilities"""
        vulnerabilities = []
        try:
            response = requests.get(self.target_url, headers=self.headers, verify=False)
                
            # Look for forms without CSRF tokens
            forms = re.findall(r'<form[^>]*>.*?</form>', response.text, re.DOTALL)
            for form in forms:
                if 'csrf' not in form.lower() and 'token' not in form.lower():
                    vulnerabilities.append({
                        'type': 'CSRF',
                        'severity': 'High',
                        'details': 'Form without CSRF protection detected',
                        'timestamp': datetime.now().isoformat()
                    })
        except Exception as e:
            logger.error(f"Error checking CSRF: {str(e)}")
        return vulnerabilities

    def check_dns_security(self):
        """Check DNS security settings"""
        vulnerabilities = []
        try:
            # Check for SPF record
            try:
                dns.resolver.resolve(self.hostname, 'TXT')
            except dns.resolver.NoAnswer:
                vulnerabilities.append({
                    'type': 'DNS Security',
                    'severity': 'Medium',
                    'details': 'No SPF record found',
                    'timestamp': datetime.now().isoformat()
                })

            # Check for DMARC record
            try:
                dns.resolver.resolve(f'_dmarc.{self.hostname}', 'TXT')
            except dns.resolver.NoAnswer:
                vulnerabilities.append({
                    'type': 'DNS Security',
                    'severity': 'Medium',
                    'details': 'No DMARC record found',
                    'timestamp': datetime.now().isoformat()
                })
        except Exception as e:
            logger.error(f"Error checking DNS security: {str(e)}")
        return vulnerabilities

    def check_server_info_disclosure(self):
        """Check for server information disclosure"""
        vulnerabilities = []
        try:
            response = requests.get(self.target_url, headers=self.headers, verify=False)
            headers = response.headers

            # Check for server header
            if 'Server' in headers:
                server_header = headers['Server']
                if server_header:
                    # Check if it contains detailed version information
                    if re.search(r'\d', server_header):  # Contains numbers (likely a version)
                        vulnerabilities.append({
                            'type': 'Information Disclosure',
                            'severity': 'Medium',
                            'details': f'Server version disclosed: {server_header}',
                            'timestamp': datetime.now().isoformat()
                        })
                    else:
                        vulnerabilities.append({
                            'type': 'Information Disclosure',
                            'severity': 'Low',
                            'details': f'Server software disclosed: {server_header}',
                            'timestamp': datetime.now().isoformat()
                        })

            # Check for X-Powered-By header
            if 'X-Powered-By' in headers:
                vulnerabilities.append({
                    'type': 'Information Disclosure',
                    'severity': 'Medium',
                    'details': f'Technology stack disclosed: {headers["X-Powered-By"]}',
                    'timestamp': datetime.now().isoformat()
                })
                
            # Check for other headers that might reveal server information
            info_headers = [
                'X-AspNet-Version', 'X-AspNetMvc-Version', 'X-Runtime',
                'X-Version', 'X-App-Version', 'X-Backend-Server',
                'X-Environment', 'X-Drupal-Cache', 'X-Generator',
                'X-Host', 'X-Middleton-Server', 'X-Origin-Server',
                'X-Server-Name', 'X-Powered-CMS'
            ]
            
            for header in info_headers:
                if header in headers:
                    vulnerabilities.append({
                        'type': 'Information Disclosure',
                        'severity': 'Medium',
                        'details': f'Server information disclosed in {header} header: {headers[header]}',
                        'timestamp': datetime.now().isoformat()
                    })
            
            # Check for server information in HTTP error pages
            error_paths = [
                '/404', '/error', '/500', '/doesnotexist',
                '/asdfghjkl', '/.git', '/.svn', '/.env',
                '/wp-admin', '/phpmyadmin', '/admin'
            ]
            
            for path in error_paths:
                try:
                    error_url = f"{self.scheme}://{self.hostname}{path}"
                    error_response = requests.get(error_url, headers=self.headers, verify=False, timeout=5)
                    
                    # Look for server stack traces or error messages
                    error_patterns = [
                        r'(?:Exception|Error)(?:\s*:|\s+at\s+|\s+in\s+).*?\.(?:java|php|py|rb|js|cs|dll)',
                        r'(?:Stack trace|Traceback|Call stack)[\s\S]*?(?:at|line|in) ',
                        r'<b>(?:Warning|Fatal error|Parse error|Notice)</b>: .*? in <b>.*?</b> on line <b>\d+</b>',
                        r'(?:\.py|\.php|\.rb|\.java|\.js|\.cs|\.go)(?:, line \d+|:\d+)',
                        r'Microsoft OLE DB Provider for SQL Server',
                        r'You have an error in your SQL syntax',
                        r'ODBC SQL Server Driver',
                        r'Microsoft JET Database Engine',
                        r'MySQL Error',
                        r'PostgreSQL Query failed',
                        r'Apache Tomcat/\d+\.\d+\.\d+'
                    ]
                    
                    for pattern in error_patterns:
                        if re.search(pattern, error_response.text):
                            vulnerabilities.append({
                                'type': 'Information Disclosure',
                                'severity': 'High',
                                'details': f'Server error message/stack trace disclosed in {path} response',
                                'timestamp': datetime.now().isoformat()
                            })
                            break
                            
                except Exception:
                    # Ignore errors for paths that don't exist
                    pass
                    
        except Exception as e:
            logger.error(f"Error checking server info: {str(e)}")
        return vulnerabilities

    def check_hsts(self):
        """Check for HTTP Strict Transport Security (HSTS) implementation"""
        vulnerabilities = []
        try:
            if self.scheme == 'https':
                response = requests.get(self.target_url, headers=self.headers, verify=False)
                headers = response.headers
                
                if 'Strict-Transport-Security' not in headers:
                    vulnerabilities.append({
                        'type': 'HSTS',
                        'severity': 'Medium',
                        'details': 'HSTS header not implemented. This may allow downgrade attacks.',
                        'timestamp': datetime.now().isoformat()
                    })
                else:
                    hsts_header = headers['Strict-Transport-Security']
                    max_age_match = re.search(r'max-age=(\d+)', hsts_header)
                    
                    if max_age_match:
                        max_age = int(max_age_match.group(1))
                        if max_age < 15768000:  # Less than 6 months
                            vulnerabilities.append({
                                'type': 'HSTS',
                                'severity': 'Low',
                                'details': f'HSTS max-age is set to {max_age} seconds, which is less than the recommended 6 months (15768000 seconds).',
                                'timestamp': datetime.now().isoformat()
                            })
                    
                    if 'includeSubDomains' not in hsts_header:
                        vulnerabilities.append({
                            'type': 'HSTS',
                            'severity': 'Low',
                            'details': 'HSTS header does not include the includeSubDomains directive.',
                            'timestamp': datetime.now().isoformat()
                        })
                        
                    if 'preload' not in hsts_header:
                        vulnerabilities.append({
                            'type': 'HSTS',
                            'severity': 'Informational',
                            'details': 'HSTS header does not include the preload directive.',
                            'timestamp': datetime.now().isoformat()
                        })
            else:
                vulnerabilities.append({
                    'type': 'HSTS',
                    'severity': 'Medium',
                    'details': 'Site is not using HTTPS. HSTS cannot be implemented.',
                    'timestamp': datetime.now().isoformat()
                })
                
        except Exception as e:
            logger.error(f"Error checking HSTS: {str(e)}")
        return vulnerabilities

    def check_spf_records(self):
        """Check for SPF (Sender Policy Framework) records"""
        vulnerabilities = []
        try:
            domain = self.hostname
            
            # If hostname includes a port, remove it
            if ':' in domain:
                domain = domain.split(':')[0]
                
            # Try to fetch TXT records which may contain SPF records
            try:
                answers = dns.resolver.resolve(domain, 'TXT')
                
                spf_found = False
                old_syntax_found = False
                incorrect_syntax = False
                weak_all = False
                
                for rdata in answers:
                    for txt_string in rdata.strings:
                        txt_str = txt_string.decode('utf-8')
                        
                        # Check for SPF records
                        if txt_str.startswith('v=spf1'):
                            spf_found = True
                            
                            # Check for deprecated syntax
                            if 'ip4:' not in txt_str and 'ip6:' not in txt_str and 'a:' not in txt_str and 'mx:' not in txt_str and 'include:' not in txt_str:
                                incorrect_syntax = True
                            
                            # Check for old syntax (check if it's using deprecated syntax)
                            if 'spf2.0/' in txt_str:
                                old_syntax_found = True
                                
                            # Check for weak configuration (ending with +all)
                            if txt_str.endswith('+all'):
                                weak_all = True
                
                if not spf_found:
                    vulnerabilities.append({
                        'type': 'SPF',
                        'severity': 'Medium',
                        'details': 'No SPF record found. This may allow email spoofing.',
                        'timestamp': datetime.now().isoformat()
                    })
                else:
                    if old_syntax_found:
                        vulnerabilities.append({
                            'type': 'SPF',
                            'severity': 'Low',
                            'details': 'Deprecated SPF syntax detected.',
                            'timestamp': datetime.now().isoformat()
                        })
                    
                    if incorrect_syntax:
                        vulnerabilities.append({
                            'type': 'SPF',
                            'severity': 'Medium',
                            'details': 'Possible incorrect SPF syntax detected.',
                            'timestamp': datetime.now().isoformat()
                        })
                        
                    if weak_all:
                        vulnerabilities.append({
                            'type': 'SPF',
                            'severity': 'High',
                            'details': 'Weak SPF configuration: Record ends with "+all" which allows any server to send mail as your domain.',
                            'timestamp': datetime.now().isoformat()
                        })                      
            except dns.resolver.NoAnswer:
                vulnerabilities.append({
                    'type': 'SPF',
                    'severity': 'Medium',
                    'details': 'No SPF record found. This may allow email spoofing.',
                    'timestamp': datetime.now().isoformat()
                })
                
            except dns.resolver.NXDOMAIN:
                vulnerabilities.append({
                    'type': 'SPF',
                    'severity': 'Medium',
                    'details': f'Domain {domain} does not exist for SPF checking.',
                    'timestamp': datetime.now().isoformat()
                })
                
        except Exception as e:
            logger.error(f"Error checking SPF records: {str(e)}")
        return vulnerabilities

    def check_server_version_outdated(self):
        """Check if the server version is outdated"""
        vulnerabilities = []
        try:
            response = requests.get(self.target_url, headers=self.headers, verify=False)
            headers = response.headers
            
            if 'Server' in headers:
                server_header = headers['Server']
                
                # Check for known outdated server versions
                outdated_servers = {
                    'Apache': {
                        'pattern': r'Apache\/(\d+\.\d+\.\d+)',
                        'outdated_versions': {
                            '2.4': 49,  # Apache 2.4.x where x < 49 is outdated
                            '2.2': 99,  # All Apache 2.2.x are outdated
                            '2.0': 99,  # All Apache 2.0.x are outdated
                            '1.3': 99   # All Apache 1.3.x are outdated
                        }
                    },
                    'nginx': {
                        'pattern': r'nginx\/(\d+\.\d+\.\d+)',
                        'outdated_versions': {
                            '1.22': 0,  # nginx 1.22.x is current stable
                            '1.21': 99, # All 1.21.x are outdated
                            '1.20': 99, # All 1.20.x are outdated
                            '1.19': 99, # All below 1.22 are outdated
                        }
                    },
                    'Microsoft-IIS': {
                        'pattern': r'Microsoft-IIS\/(\d+\.\d+)',
                        'outdated_versions': {
                            '10.0': 99, # IIS 10.0 and below should check for patches
                            '8.5': 99,  # IIS 8.5 and below are outdated
                            '8.0': 99,
                            '7.5': 99,
                            '7.0': 99,
                            '6.0': 99,
                            '5.0': 99
                        }
                    }
                }
                
                for server_name, server_data in outdated_servers.items():
                    if server_name in server_header:
                        pattern = server_data['pattern']
                        match = re.search(pattern, server_header)
                        
                        if match:
                            version = match.group(1)
                            version_parts = version.split('.')
                            
                            if len(version_parts) >= 2:
                                major_minor = f"{version_parts[0]}.{version_parts[1]}"
                                patch = int(version_parts[2]) if len(version_parts) > 2 else 0
                                
                                if major_minor in server_data['outdated_versions'] and patch < server_data['outdated_versions'][major_minor]:
                                    vulnerabilities.append({
                                        'type': 'Server Version',
                                        'severity': 'High',
                                        'details': f'Outdated {server_name} version {version} detected. This may contain known security vulnerabilities.',
                                        'timestamp': datetime.now().isoformat()
                                    })
                                    
                # Generic outdated server detection
                outdated_server_keywords = [
                    'Apache/1', 'Apache/2.0', 'Apache/2.2',
                    'nginx/1.0', 'nginx/1.1', 'nginx/1.2', 
                    'Microsoft-IIS/5.0', 'Microsoft-IIS/6.0', 'Microsoft-IIS/7.0',
                    'PHP/5.', 'PHP/4.',
                    'OpenSSL/0.9', 'OpenSSL/1.0.0', 'OpenSSL/1.0.1',
                    'Tomcat/4', 'Tomcat/5', 'Tomcat/6'
                ]
                
                for keyword in outdated_server_keywords:
                    if keyword in server_header:
                        vulnerabilities.append({
                            'type': 'Server Version',
                            'severity': 'High',
                            'details': f'Outdated server software detected: {server_header}',
                            'timestamp': datetime.now().isoformat()
                        })
                        break
                        
        except Exception as e:
            logger.error(f"Error checking server version: {str(e)}")
        return vulnerabilities

    def check_software_version_disclosure(self):
        """Check for software version disclosure in HTTP headers, HTML comments, and JavaScript"""
        vulnerabilities = []
        try:
            response = requests.get(self.target_url, headers=self.headers, verify=False)
            headers = response.headers
            
            # Check headers for software/framework versions
            sensitive_headers = [
                'X-Powered-By', 'X-AspNet-Version', 'X-AspNetMvc-Version',
                'X-Generator', 'X-Drupal-Cache', 'X-Drupal-Dynamic-Cache',
                'X-Varnish-Cache', 'X-Magento-Cache-Debug', 'X-Shopify-Stage',
                'X-WP-Total', 'X-WP-TotalPages', 'X-WordPress', 'X-Pantheon-Styx-API',
                'X-CF-Powered-By', 'X-Wix-Request-Id', 'X-Shopify-Stage'
            ]
            
            for header in sensitive_headers:
                if header in headers:
                    vulnerabilities.append({
                        'type': 'Information Disclosure',
                        'severity': 'Medium',
                        'details': f'Software version disclosure in {header} header: {headers[header]}',
                        'timestamp': datetime.now().isoformat()
                    })
            
            # Check HTML comments for version information
            html_content = response.text
            
            # Common patterns for version disclosure in comments
            version_patterns = [
                r'<!--.*[Vv]ersion\s*:?\s*([\d\.]+).*-->',
                r'<!--.*[Vv]\s*:?\s*([\d\.]+).*-->',
                r'<!--.*[Bb]uild\s*:?\s*([\d\.]+).*-->',
                r'<!--\s*(?:WordPress|Drupal|Joomla|Magento|Laravel)\s*[Vv]ersion\s*:?\s*([\d\.]+)\s*-->',
                r'var\s+(?:WP_VERSION|DRUPAL_VERSION|JOOMLA_VERSION|TYPO3_VERSION)\s*=\s*[\'\"]([\d\.]+)[\'\"]\s*;'
            ]
            
            for pattern in version_patterns:
                matches = re.findall(pattern, html_content)
                for match in matches:
                    vulnerabilities.append({
                        'type': 'Information Disclosure',
                        'severity': 'Medium',
                        'details': f'Software version disclosure in HTML comments: Version {match}',
                        'timestamp': datetime.now().isoformat()
                    })
            
            # Check for metadata in HTML
            meta_patterns = [
                r'<meta\s+name=["\'](generator|platform|framework|cms)["\']\s+content=["\'](.*?)["\']',
                r'<meta\s+content=["\'](.*?)["\']\s+name=["\'](generator|platform|framework|cms)["\']'
            ]
            
            for pattern in meta_patterns:
                matches = re.findall(pattern, html_content, re.IGNORECASE)
                for match in matches:
                    content = match[1] if match[0].lower() in ['generator', 'platform', 'framework', 'cms'] else match[0]
                    if content and re.search(r'\d', content):  # Contains numbers (likely a version)
                        vulnerabilities.append({
                            'type': 'Information Disclosure',
                            'severity': 'Medium',
                            'details': f'Software version disclosure in meta tag: {content}',
                            'timestamp': datetime.now().isoformat()
                        })
            
            # Check for JavaScript variables with version information
            js_version_patterns = [
                r'var\s+(?:version|appVersion|VERSION|APP_VERSION)\s*=\s*[\'\"]([\d\.]+)[\'\"]\s*;',
                r'const\s+(?:version|appVersion|VERSION|APP_VERSION)\s*=\s*[\'\"]([\d\.]+)[\'\"]\s*;',
                r'let\s+(?:version|appVersion|VERSION|APP_VERSION)\s*=\s*[\'\"]([\d\.]+)[\'\"]\s*;',
                r'window\.(?:version|appVersion|VERSION|APP_VERSION)\s*=\s*[\'\"]([\d\.]+)[\'\"]\s*;'
            ]
            
            for pattern in js_version_patterns:
                matches = re.findall(pattern, html_content)
                for match in matches:
                    vulnerabilities.append({
                        'type': 'Information Disclosure',
                        'severity': 'Low',
                        'details': f'Software version disclosure in JavaScript: Version {match}',
                        'timestamp': datetime.now().isoformat()
                    })
                    
            # Check for version in common file paths
            version_files = [
                '/version.txt', '/VERSION.txt', '/version', '/VERSION',
                '/readme.txt', '/README.txt', '/README.md', '/CHANGELOG.md',
                '/CHANGELOG.txt', '/changelog.txt', '/release-notes.txt'
            ]
            
            for file_path in version_files:
                try:
                    version_url = f"{self.scheme}://{self.hostname}{file_path}"
                    version_response = requests.get(version_url, headers=self.headers, verify=False, timeout=3)
                    
                    if version_response.status_code == 200 and len(version_response.text) < 5000:  # Reasonable size for version file
                        # Look for version pattern in the content
                        version_match = re.search(r'[Vv]ersion\s*:?\s*([\d\.]+)', version_response.text)
                        if version_match or re.search(r'^\s*[\d\.]+\s*$', version_response.text.strip()):
                            vulnerabilities.append({
                                'type': 'Information Disclosure',
                                'severity': 'Medium',
                                'details': f'Software version disclosure in {file_path} file',
                                'timestamp': datetime.now().isoformat()
                            })
                except Exception as file_error:
                    # Ignore errors for file not found
                    pass
                    
        except Exception as e:
            logger.error(f"Error checking software version disclosure: {str(e)}")
        return vulnerabilities

def main():
    import sys
    import argparse
    
    parser = argparse.ArgumentParser(description='Vulnerability Scanner')
    parser.add_argument('url', help='Target URL to scan')
    parser.add_argument('--scan-type', default='full', choices=['full', 'quick', 'custom'], 
                        help='Type of scan to perform')
    parser.add_argument('--checks', nargs='+', 
                        choices=['ssl', 'headers', 'ports', 'xss', 'sqli', 'csrf', 'dns', 'info', 
                                'hsts', 'spf', 'server', 'software'],
                        help='Specific checks to run (used with --scan-type=custom)')
    
    # For backward compatibility with direct calls passing only URL
    if len(sys.argv) == 2 and not sys.argv[1].startswith('-'):
        args = parser.parse_args([sys.argv[1]])
    else:
        args = parser.parse_args()
        
    target_url = args.url
    scanner = VulnerabilityScanner(target_url)
    
    start_time = datetime.now()
    
    # Run specific checks if custom scan type
    if args.scan_type == 'custom' and args.checks:
        vulnerabilities = []
        for check in args.checks:
            if check == 'ssl':
                vulnerabilities.extend(scanner.check_ssl_tls())
            elif check == 'headers':
                vulnerabilities.extend(scanner.check_headers())
            elif check == 'ports':
                vulnerabilities.extend(scanner.check_open_ports())
            elif check == 'xss':
                vulnerabilities.extend(scanner.check_xss_vulnerability())
            elif check == 'sqli':
                vulnerabilities.extend(scanner.check_sql_injection())
            elif check == 'csrf':
                vulnerabilities.extend(scanner.check_csrf())
            elif check == 'dns':
                vulnerabilities.extend(scanner.check_dns_security())
            elif check == 'info':
                vulnerabilities.extend(scanner.check_server_info_disclosure())
            elif check == 'hsts':
                vulnerabilities.extend(scanner.check_hsts())
            elif check == 'spf':
                vulnerabilities.extend(scanner.check_spf_records())
            elif check == 'server':
                vulnerabilities.extend(scanner.check_server_version_outdated())
            elif check == 'software':
                vulnerabilities.extend(scanner.check_software_version_disclosure())
    else:
        # Default full scan
        vulnerabilities = scanner.scan()
    
    end_time = datetime.now()
    scan_duration = (end_time - start_time).total_seconds()
    
    # Format results for Node.js backend
    results = {
        'vulnerabilities': [
            {
                'type': vuln['type'],
                'severity': vuln['severity'],
                'description': vuln['details'],
                'location': target_url,
                'payload': None  # Add payload if available
            }
            for vuln in vulnerabilities
        ],
        'scan_duration': scan_duration,
        'scan_time': datetime.now().isoformat(),
        'scan_type': args.scan_type,
        'target': target_url,
        'vulnerability_count': len(vulnerabilities),
        'status': 'completed',
        'summary': {
            'critical': len([v for v in vulnerabilities if v['severity'] == 'Critical']),
            'high': len([v for v in vulnerabilities if v['severity'] == 'High']),
            'medium': len([v for v in vulnerabilities if v['severity'] == 'Medium']),
            'low': len([v for v in vulnerabilities if v['severity'] == 'Low']),
            'informational': len([v for v in vulnerabilities if v['severity'] == 'Informational'])
        }
    }
    
    # Output JSON to stdout for Node.js to capture
    print(json.dumps(results))

if __name__ == '__main__':
    main() 